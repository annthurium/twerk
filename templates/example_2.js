WIDTH = HEIGHT = 500;

// After the window is loaded, call DrawRandomCunt.
addEventListener('load', DrawCunt, false);

// function DrawRandomCunt() {
//   // We're flipping WIDTH and HEIGHT here, because we're going to
//   // plot this sideways.
//   //labia_data = GenRandomCunt(1, 4, HEIGHT, WIDTH);

//   labia_data = [
//          [ {x: 0, y: 0.0},
//            {x: 25, y: 23.3},
//            {x: 50, y: 83.2},
//            {x: 75, y: 1.1},
//            {x: 100, y: 0.0}
//          ]
//       ]
//   DrawCunt(labia_data);
// }

// x is time
// y is count of words
var play_data = [
  {
    "name": "primary",
    "values": [
      { "x": 0, "y": 20},
      { "x": 25, "y": 30},
      { "x": 50, "y": 70},
      { "x": 75, "y": 40}
    ]
  },
  {
    "name": "secondary",
    "values": [
      { "x": 0, "y": 20},
      { "x": 25, "y": 30},
      { "x": 50, "y": 70},
      { "x": 75, "y": 40}
    ]
  },
  {
    "name": "emotions",
    "values": [
      { "x": 0, "y": 20},
      { "x": 25, "y": 30},
      { "x": 50, "y": 70},
      { "x": 75, "y": 40}
    ]
  }
];
/**
 * GenRandomCunt generates random data to be plotted as a stream
 * diagram, in homage to Georgia O'Keefe.
 * 
 * Every layer will have the same number of points, and the points will be
 * aligned on x. That is, the nth point of each layer will have the same
 * x value.
 *
 * Example:
 *   GenRandomCunt(1, 4, 100, 100);
 *
 *   Returns something like:
 *     [
 *        [ {x: 0, y: 0.0},
 *          {x: 25, y: 23.3},
 *          {x: 50, y: 83.2},
 *          {x: 75, y: 1.1},
 *          {x: 100, y: 0.0}
 *        ]
 *     ]
 *
 * Note that data produced by this function is "sideways", because
 * d3.layout.stack() stacks layers vertically (on top of each other),
 * whereas labial lips are stacked next to each other. You'll probably
 * want to swap x and y when you draw it, but there's really no wrong
 * way to draw a vagina.
 *
 * Arguments:
 *   num_layers  the number of layers to generate.
 *   num_points  the number of points in each layer.
 *   width       the width of the diagram (max x).
 *   height      the height of the diagram (max y).
 *
 * Returns:
 *   An array of layers, where each layer is an array of points, as
 *   generated by the P function above.
 */
// function GenRandomCunt(num_layers, num_points, width, height) {
//   // As i varies from 0 to (num_points - 1), the x coordinate varies
//   // from 0 to width.
//   var i_to_x_transform = d3.scale.linear()
//     .domain([0, num_points - 1])
//     .range([0, width]);

//   // We pick random y values using Math.random(), which returns
//   // values in the range (0.0, 1.0), which is the default domain
//   // for d3.scale.linear. We set the range to be between
//   // height / num_layers and zero, because we want all the slices
//   // to fit in the chart.
//   var y_transform = d3.scale.linear()
//         .range([height / num_layers, 0]);

//   // i_to_cunt_transform is a multi-part linear transform.
//   // For the first half of the graph (0 to (num_points - 1) / 2),
//   // cunt_transform goes from 0 to 1.0. For the second half, it
//   // goes from 1.0 to 0. This means that the first and last points
//   // generated will always be zero, and the points in between will
//   // ramp up and fall away linearly, creating the impression of
//   // labial lips when plotted with appropriate smoothing and colors.
//   var i_to_cunt_transform = d3.scale.linear()
//     .domain([0, (num_points - 1) / 2, num_points - 1])
//     .range([0, 1.0, 0.0]);

//   var layers = [];
//   for (var i = 0; i != num_points; ++i) {
//     // Every point shares the same x coordinate.
//     var x = i_to_x_transform(i);
//     for (var j = 0; j != num_layers; ++j) {
//       // Layers and layers, opening into...
//       if (i == 0) {
//         // If this is the first time this layer has been visited,
//         // we'll need to create an empty array to hold the points.
//         layers.push([]);
//       }
//       // Multiplying by the cunt transform gives us the nice labial shape.
//       var y = i_to_cunt_transform(i) * y_transform(Math.random());
//       // Add this point to the current layer.
//       layers[j].push({x: x, y: y});
//     }
//   }
//   return layers;
// }

function DrawCunt(labia_data, width, height) {
  // Stacker is a function that will take each layer of labia_data
  // and stack it vertically for display.
  var stacker = d3.layout.stack()
    .offset('wiggle');

  // Nice cunty colors.
  var color = d3.scale.linear().range(["#609", "#e0f"]);

  // We need to flip x and y here, because stacker produces a y-aligned
  // baseline (that is, it assumes that the chart stacks up).
  //
  // Area generates SVG path data when called on a list of data points.
  var area = d3.svg.area()
    .x0(function(d) { return d.y0; })
    .x1(function(d) { return d.y0 + d.y; })
    .y(function(d) { return d.x; })
    //.interpolate('basis');  // this is important for a smooth cunt.

  // Add an svg element to the body.
  var svg = d3.select("body")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  // Create a path (a filled area) for each of the many layers upon layers.
  svg.selectAll("path")
    .data(stacker(labia_data))
    .enter()
      .append("path")
      .attr("d", area)
      .style("fill", function() { 
        return color(Math.random()); 
      });
}
